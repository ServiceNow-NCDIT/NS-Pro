<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_g_sonc_ns_pro.circuit</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>circuit</name>
        <script><![CDATA[var circuit = Class.create();
circuit.prototype = {
    circuitSpeedMultiplier: 0,

    initialize: function() {
        this.debug = true;
        this.circuitSpeedMultiplier = gs.getProperty('x_g_sonc_ns_pro.circuit_speed_multiplier');

    },

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    timestamp: function() {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return new GlideDateTime().getNumericValue();
    },

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getDistance2Point: function(lat1, lon1, lat2, lon2) {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // calculates distance between two points using the Haversine formula.
        var LogPrefix = "getDistance2Point ";
        if (this.debug) gs.info(this.timestamp() + LogPrefix + " called, lat1 = " + lat1.toString() + ", lon1 = " + lon1.toString() + ", lat2 = " + lat2.toString() + ", lon2 = " + lon2.toString());
        var Rkm = 6371; // Radius of the earth in km
        var dLat = (lat2 - lat1) * (Math.PI / 180);
        var dLon = (lon2 - lon1) * (Math.PI / 180);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = Rkm * c; // Distance in km
        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' returning ' + d);
        return d;
    },

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getHostPort: function(NSProTask) {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        var LogPrefix = " circuit().getHostPort --> ";

        var localCircuitMultiplier = gs.getProperty('x_g_sonc_ns_pro.circuit_speed_multiplier');


        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for task ' + NSProTask.number);
        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for network_service_category ' + NSProTask.network_service_category);
        // is this best effort?
        if (NSProTask.network_service_category == 'best_effort') {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + ' for best_effort network_service_category');
            // return host circuit dummy record instructing use of firewall
            //Per Keith - us the Agency Code from the site Record and Firewall
            //Example DOT Firewall.  If the Site Record does not have the Agency Code Populated use  Agency Firewall
            var bestEffortResponse = "Agency Firewall";
            if (NSProTask.site.x_g_sonc_ns_pro_agency) {
                bestEffortResponse = bestEffortResponse.replace("Agency", NSProTask.site.x_g_sonc_ns_pro_agency.abbreviation.toString());
            }

            var hostCircuit = {};
            hostCircuit.x_g_sonc_ns_pro_pop_pe_interface = bestEffortResponse;
            hostCircuit.pop = bestEffortResponse;
            hostCircuit.pop_dv = bestEffortResponse;
            hostCircuit.pe_router = bestEffortResponse;
            hostCircuit.pe_router_dv = bestEffortResponse;

            return JSON.stringify(hostCircuit);
        }

        // execute this for guaranteed service
        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' for guaranteed network_service_category');
        // get provider record
        var grProvider = new GlideRecord('x_g_sonc_ns_pro_telco_provider');
        var hostCircuits = this.getHostCircuitsForProvider(NSProTask.telco_provider); // retrieve an array of host circuit records
        var hostsWithCapacity = [];
        // identify circuits with capacity and fewer than 100 sites per circuit
        if (hostCircuits.length == 0) {
            gs.addErrorMessage('No host circuits returned for provider. Please select a new provider and try again.');
        } else {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + 'getHostCircuitsForProvider returned ' + hostCircuits.length + ' circuits');
            for (i = 0; i < hostCircuits.length; i++) {
                if (this.debug) gs.info(this.timestamp() + LogPrefix + 'Checking capacity of ' + hostCircuits[i].circuit_id + ' with avail capacity of ' + hostCircuits[i].available_capacity + ' and site_count ' + hostCircuits[i].site_count);
                if (parseInt(hostCircuits[i].available_capacity) - parseInt(NSProTask.speed * localCircuitMultiplier) > 0 && hostCircuits[i].site_count < 100) {
                    if (this.debug) gs.info(this.timestamp() + LogPrefix + 'pushing ' + hostCircuits[i].circuit_id + ' to hostsWithCapacity');
                    hostsWithCapacity.push(hostCircuits[i]);
                }
            }
            //WORK AROUND IF NO HOSTS WITH CAPACITY ALLOW OVER SUBSCRIBE
            //check if we have any hostsWithCapacity if not then put all in hostsWithCapacity array
            if (hostsWithCapacity.length < 1) {
                hostsWithCapacity = hostCircuits;
            }
            var closestCircuit = this.getClosestCircuit(NSProTask, hostsWithCapacity);
            NSProTask.circuit = closestCircuit.sys_id;
            NSProTask.update();
            gs.addErrorMessage('Closest circuit is ' + JSON.stringify(closestCircuit));
            return JSON.stringify(closestCircuit);
        }
        return; // null, could not find a closest circuit

    },
    _getHostPortInformation: function(hostCircuitSysId) {
        var hostPort;
        var queryString = 'pe_host_circuit_id.sys_id=' + hostCircuitSysId + '^local_circuit_id.sys_id=' + hostCircuitSysId + '^ip_addressISEMPTY';
        var portRecord = new GlideRecord('x_g_sonc_ns_pro_port');
        portRecord.addEncodedQuery(queryString);
        portRecord.query();

        if (portRecord.next()) {
            hostPort = {};
            hostPort.AssignedPEPort = portRecord.getValue('name');
            hostPort.assignedPort = portRecord.sys_id;
            hostPort.AssingedPEDevice = portRecord.getValue('network_gear');
            hostPort.AssingedPEHost = portRecord.getElement('network_gear.name').toString();
        } else {
            hostPort = {};
            hostPort.AssignedPEPort = "";
            hostPort.AssingedPEDevice = "";
            hostPort.AssingedPEHost = "";
        }
        return hostPort;

    },
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getHostCircuitsForProvider: function(provider) {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        var LogPrefix = " circuit().getHostForProvider --> ";

        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for provider ' + provider);

        var hostCircuits = [];
        var queryStr = 'x_g_sonc_ns_pro_host_ckt=true^x_g_sonc_ns_pro_circuit_typeINase,p2p_ase,me,p2p_me^install_statusIN1,4^x_g_sonc_ns_pro_telco_provider=' + provider;
        var gr = new GlideRecord('cmdb_ci_network_circuit');
        gr.addEncodedQuery(queryStr);
        gr.query();
        while (gr.next()) {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + 'found host circuit ' + gr.name);
            var hostCircuit = {};
            hostCircuit.sys_id = gr.getUniqueValue();
            hostCircuit.circuit_id = gr.getValue('name');
            //if available capacity is empty assume capacity is full
            if (gs.nil(gr.getValue('x_g_sonc_ns_pro_available_capacity'))) {
                hostCircuit.available_capacity = 0;
            } else {
                hostCircuit.available_capacity = gr.getValue('x_g_sonc_ns_pro_available_capacity');
            }
            //if site count is empty assume 100
            if (gs.nil(gr.getValue('x_g_sonc_ns_pro_site_count'))) {
                hostCircuit.site_count = 100;
            } else {
                hostCircuit.site_count = gr.getValue('x_g_sonc_ns_pro_site_count');
            }
            hostCircuit.pe_host_circuit_id = gr.getValue('x_g_sonc_ns_pro_pe_host_circuit_id');
            hostCircuit.circuit_type = gr.getValue('x_g_sonc_ns_pro_circuit_type');
            hostCircuit.circuit_status = gr.getValue('x_g_sonc_ns_pro_status');
            hostCircuit.circuit_speed = gr.getValue('x_g_sonc_ns_pro_circuit_speed');
            hostCircuit.pop = gr.getValue('x_g_sonc_ns_pro_point_of_presence');
            hostCircuit.pop_dv = gr.getDisplayValue('x_g_sonc_ns_pro_point_of_presence');
            hostCircuit.telco_provider = gr.getValue('x_g_sonc_ns_pro_telco_provider');
            hostCircuit.telco_provider_dv = gr.getDisplayValue('x_g_sonc_ns_pro_telco_provider');
            var hostCircuitPort = this._getHostPortInformation(gr.getValue('sys_id'));
            if (!gs.nil(hostCircuitPort)) {
                hostCircuit.x_g_sonc_ns_pro_pop_pe_interface = hostCircuitPort.AssignedPEPort;
                hostCircuit.pe_router = hostCircuitPort.AssingedPEDevice;
                hostCircuit.pe_router_dv = hostCircuitPort.AssingedPEHost;
            } else {
                hostCircuit.x_g_sonc_ns_pro_pop_pe_interface = null;
                hostCircuit.pe_router = null;
                hostCircuit.pe_router_dv = null;

            }
            hostCircuits.push(hostCircuit);
        }
        // if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning host circuits ' + JSON.stringify(hostCircuits));
        return hostCircuits; // null = no hostCircuits

    },

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getClosestCircuit: function(NSProTask, hostsWithCapacity) {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        var LogPrefix = " circuit().getClosestCircuits --> ";

        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for task ' + NSProTask.number);

        var locLat = NSProTask.location.latitude;
        var locLon = NSProTask.location.longitude;
        var closestDist = 9999; // artificially high so even the first distance comparison will be closer
        // var closestCircuit = hostsWithCapacity[0]; // just to set a default to begin comparisons against for closest circuit
        var closestCircuit;
        for (i = 0; i < hostsWithCapacity.length; i++) {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + 'hostsWithCapacity[' + i + '] circuit = ' + hostsWithCapacity[i].circuit_id);
            var pop = hostsWithCapacity[i].pop;
            var grPop = new GlideRecord('x_g_sonc_ns_pro_point_of_presence');
            if (grPop.get(pop)) {
                if (this.debug) gs.info(this.timestamp() + LogPrefix + 'hostsWithCapacity[' + i + '] pop = ' + grPop.name);
                var dist = this.getDistance2Point(locLat, locLon, grPop.location.latitude, grPop.location.longitude);
                if (this.debug) gs.info(this.timestamp() + LogPrefix + hostsWithCapacity[i].circuit_id + ' dist = ' + dist + '. Closest dist = ' + closestDist);
                if (dist < closestDist) {
                    closestCircuit = hostsWithCapacity[i];
                    closestDist = dist;
                }
            } else {
                if (this.debug) gs.info(this.timestamp() + LogPrefix + 'hostsWithCapacity[' + i + ']  Missing pop Property or Pop Query returned null');
            }
        }

        if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning closestCircuit ' + JSON.stringify(closestCircuit));
        return closestCircuit;

    },
    _getSubscribedSiteCount: function(hostCirSysID) {
        var siteCountTotal = 0;
        var queryString = 'x_g_sonc_ns_pro_pe_host_circuit_id=' + hostCirSysID + '^x_g_sonc_ns_pro_host_ckt=false^install_statusIN1,4';
        var localCircuits = new GlideRecord('cmdb_ci_network_circuit');
        localCircuits.addEncodedQuery(queryString);
        localCircuits.query();

        while (localCircuits.next()) {
            siteCountTotal += 1;
        }

        return siteCountTotal;
    },
    _getSubscribedCapacity: function(hostCirSysID) {
        var subscribedTotal = 0;
        var queryString = 'x_g_sonc_ns_pro_pe_host_circuit_id=' + hostCirSysID + '^x_g_sonc_ns_pro_host_ckt=false^install_statusIN1,4';
        var localCircuits = new GlideRecord('cmdb_ci_network_circuit');
        localCircuits.addEncodedQuery(queryString);
        localCircuits.query();

        while (localCircuits.next()) {
            var cirSpeed = localCircuits.getValue('x_g_sonc_ns_pro_circuit_speed');
            if (!gs.nil(cirSpeed)) {
                subscribedTotal = subscribedTotal + parseInt(cirSpeed);
            }
        }

        return subscribedTotal;
    },
    updateHostCircuitAvailableCapacity: function(hostCircuitSysID) {
        var circuitSpeedMultiplier = gs.getProperty('x_g_sonc_ns_pro.circuit_speed_multiplier');
        var hostCir = new GlideRecord('cmdb_ci_network_circuit');
        if (hostCir.get(hostCircuitSysID)) {
            var hostCircuitCapacity = 0;
            var hostSiteCount = 0;
            var hstCirCap = hostCir.getValue('x_g_sonc_ns_pro_circuit_speed');
            var hstSiteCount = hostCir.getValue('x_g_sonc_ns_pro_site_count');
            var hstCir_sysID = hostCir.getValue('sys_id');
            if (!gs.nil(hstCirCap)) {
                hostCircuitCapacity = parseInt(hstCirCap) * circuitSpeedMultiplier;
            }
            if (!gs.nil(hstSiteCount)) {
                hostSiteCount = parseInt(hstSiteCount);
            }
            var subscribedCapacity = this._getSubscribedCapacity(hostCircuitSysID);
            var subscribedSites = this._getSubscribedSiteCount(hostCircuitSysID);

            if (!gs.nil(subscribedCapacity)) {
                var availableCapacity = hostCircuitCapacity - (subscribedCapacity * circuitSpeedMultiplier);
                hostCir.setValue('x_g_sonc_ns_pro_available_capacity', availableCapacity);
            }
            if (!gs.nil(subscribedSites)) {
                hostCir.setValue('x_g_sonc_ns_pro_site_count', subscribedSites);
            }
            hostCir.update();
        }

    },
    loadCircuitSiteSelection: function(telco, site) {
        var siteLocation;
        var queryString = 'x_g_sonc_ns_pro_host_ckt=true^install_status=1';
        var hostCirArray = [];
        var hostCir = new GlideRecord('cmdb_ci_network_circuit');
        if (!gs.nil(site)) {
            var siteObj = new x_g_sonc_ns_pro.cmdb_ci_site();
            siteLocation = siteObj._getSiteLocationInfo(site);
        }
        if (!gs.nil(telco)) {
            queryString = queryString + '^x_g_sonc_ns_pro_telco_provider=' + telco;
        }
        hostCir.addEncodedQuery(queryString);
        hostCir.query();

        while (hostCir.next()) {
            var hostObj = {};
            var hostCircuitCapacity = 0;
            var hostSiteCount = 0;
            var hstCirCap = hostCir.getValue('x_g_sonc_ns_pro_circuit_speed');
            var hstSiteCount = hostCir.getValue('x_g_sonc_ns_pro_site_count');
            var hstCir_sysID = hostCir.getValue('sys_id');
            if (!gs.nil(hstCirCap)) {
                hostCircuitCapacity = parseInt(hstCirCap) * this.circuitSpeedMultiplier;
            }
            if (!gs.nil(hstSiteCount)) {
                hostSiteCount = parseInt(hstSiteCount);
            }
            hostObj.sys_id = hstCir_sysID;
            hostObj.host_circuit = hstCir_sysID;
            hostObj.total_capacity = hostCircuitCapacity;
            hostObj.site = siteLocation.siteSysID;
            hostObj.telco_provider = hostCir.getValue('x_g_sonc_ns_pro_telco_provider');
            hostObj.point_of_presence = hostCir.getValue('x_g_sonc_ns_pro_point_of_presence');

            var subscribedCapacity = this._getSubscribedCapacity(hstCir_sysID);
            var subscribedSites = this._getSubscribedSiteCount(hstCir_sysID);

            hostObj.site_count = subscribedSites;
            hostObj.total_subscribed_capacity = subscribedCapacity * this.circuitSpeedMultiplier;
            hostObj.available_capacity = hostObj.total_capacity - hostObj.total_subscribed_capacity;

            var hostCirPort = this._getHostPortInformation(hstCir_sysID);
            //hostObj.host_circuit_port = hostCirPort.AssignedPEPort;
            //gs.info(hstCir_sysID);
            hostObj.host_circuit_port = hostCirPort.assignedPort;

            var popLocationLatitude = parseFloat(hostCir.getElement('x_g_sonc_ns_pro_point_of_presence.location.latitude'));
            var popLocationLongitude = parseFloat(hostCir.getElement('x_g_sonc_ns_pro_point_of_presence.location.longitude'));



            if (!gs.nil(siteLocation)) {
                var distance = this.getDistance2Point(siteLocation.locationLatitude, siteLocation.locationLongitude, popLocationLatitude, popLocationLongitude);
                //convert kilometers into miles
                distance = distance / 1.609;
                hostObj.distance = distance.toFixed(4);
            }

            hostCirArray.push(hostObj);
        }
        return hostCirArray;
    },
    loadHostCircuitWithCapacity: function(telco, hostCircuit, pop) {
        var siteLocation;
        var queryString = 'x_g_sonc_ns_pro_host_ckt=true^install_status=1';
        var hostCirArray = [];
        var hostCir = new GlideRecord('cmdb_ci_network_circuit');
        if (!gs.nil(hostCircuit)) {
            queryString = queryString + '^sys_id=' + hostCircuit;
        }
        if (!gs.nil(telco)) {
            queryString = queryString + '^x_g_sonc_ns_pro_telco_provider=' + telco;
        }
        if (!gs.nil(pop)) {
            queryString = queryString + '^x_g_sonc_ns_pro_point_of_presence=' + pop;
        }

        hostCir.addEncodedQuery(queryString);
        hostCir.query();

        while (hostCir.next()) {
            var hostObj = {};
            var hostCircuitCapacity = 0;
            var hostSiteCount = 0;
            var hstCirCap = hostCir.getValue('x_g_sonc_ns_pro_circuit_speed');
            var hstSiteCount = hostCir.getValue('x_g_sonc_ns_pro_site_count');
            var hstCir_sysID = hostCir.getValue('sys_id');
            if (!gs.nil(hstCirCap)) {
                hostCircuitCapacity = parseInt(hstCirCap) * this.circuitSpeedMultiplier;
            }
            if (!gs.nil(hstSiteCount)) {
                hostSiteCount = parseInt(hstSiteCount);
            }
            hostObj.sys_id = hstCir_sysID;
            hostObj.host_circuit = hstCir_sysID;
            hostObj.total_capacity = hostCircuitCapacity;
            hostObj.telco_provider = hostCir.getValue('x_g_sonc_ns_pro_telco_provider');
            hostObj.point_of_presence = hostCir.getValue('x_g_sonc_ns_pro_point_of_presence');

            var subscribedCapacity = this._getSubscribedCapacity(hstCir_sysID);
            var subscribedSites = this._getSubscribedSiteCount(hstCir_sysID);

            hostObj.site_count = subscribedSites;
            hostObj.total_subscribed_capacity = subscribedCapacity * this.circuitSpeedMultiplier;
            hostObj.available_capacity = hostObj.total_capacity - hostObj.total_subscribed_capacity;

            var hostCirPort = this._getHostPortInformation(hstCir_sysID);
            //hostObj.host_circuit_port = hostCirPort.AssignedPEPort;
            //gs.info(hstCir_sysID);
            hostObj.host_circuit_port = hostCirPort.assignedPort;

            var popLocationLatitude = parseFloat(hostCir.getElement('x_g_sonc_ns_pro_point_of_presence.location.latitude'));
            var popLocationLongitude = parseFloat(hostCir.getElement('x_g_sonc_ns_pro_point_of_presence.location.longitude'));

            hostCirArray.push(hostObj);
        }
        return hostCirArray;
    },
    getHostCircuitInformation: function(hostCircuitSysID) {
        var response = {};
        var errorString;

        try {
            var hostCircuit = new GlideRecord('cmdb_ci_network_circuit');
            if (hostCircuit.get(hostCircuitSysID)) {
                hostCircuitPort = this._getHostPortInformation(hostCircuitSysID);
                response.hostCirSysID = hostCircuitSysID;
                response.pop = hostCircuit.getValue('x_g_sonc_ns_pro_point_of_presence');
                response.pe_router = hostCircuitPort.AssingedPEDevice;
                response.pe_router_dv = hostCircuitPort.AssingedPEHost;
                response.x_g_sonc_ns_pro_pop_pe_interface = hostCircuitPort.AssignedPEPort;
                response.message = "Host Circuit = " + hostCircuit.getValue('name');
            }
        } catch (ex) {
            response.message = "Error Occured in x_g_sonc_ns_pro.circuit.getHostCircuitInformation() " + ex.toString();
        }
        return response;
    },
    createTemporaryCircuit: function(taskSysID) {
        var errorstring;
        response = {};

        try {
            var lastNumber = 0;
            var NSPROTask = new GlideRecord(NSPROConstants.TABLES.TASK);
            if (NSPROTask.get(taskSysID)) {
                var circuitSite = NSPROTask.getValue('site');
                var taskNumber = NSPROTask.getValue('number');
                var hostCircuit = NSPROTask.getValue('circuit');
                var netWorkCircuit = new GlideRecord(NSPROConstants.TABLES.CIRCUITS);
                netWorkCircuit.addQuery('name', 'STARTSWITH', taskNumber);
                netWorkCircuit.addQuery('x_g_sonc_ns_pro_site', circuitSite);
                netWorkCircuit.addQuery('x_g_sonc_ns_pro_pe_host_circuit_id', hostCircuit);
                netWorkCircuit.orderByDesc('name');
                netWorkCircuit.setLimit(1);
                netWorkCircuit.query();

                if (netWorkCircuit.next()) {
                    var lastCircuitName = netWorkCircuit.getValue('name');
                    gs.info(lastCircuitName);
                    var circuitNumberArray = lastCircuitName.split('-');
                    if (circuitNumberArray.length > 1) {
                        gs.info(circuitNumberArray[1]);
                        lastNumber = parseInt(circuitNumberArray[1]);
                        lastNumber += 1;
                    } else {
                        lastNumber = 1;
                    }


                }
                var newCircuitNumber = taskNumber;
                if (lastNumber > 0) {
                    newCircuitNumber = newCircuitNumber + '-' + lastNumber;
                }

                var newCircuit = new GlideRecord(NSPROConstants.TABLES.CIRCUITS);
                newCircuit.initialize();
                newCircuit.setValue('name', newCircuitNumber);
                newCircuit.setValue('x_g_sonc_ns_pro_pe_host_circuit_id', NSPROTask.getValue('circuit'));
                newCircuit.setValue('x_g_sonc_ns_pro_telco_provider', NSPROTask.getValue('telco_provider'));
                newCircuit.setValue('access_type', NSPROTask.getValue('assigned_pe_port'));
                newCircuit.setValue('correlation_id', NSPROTask.getValue('assigned_pe_port'));
                newCircuit.setValue('serial_number', NSPROTask.getValue('assigned_pe_port'));
                newCircuit.setValue('x_g_sonc_ns_pro_site', NSPROTask.getValue('site'));
                newCircuit.setValue('bandwidth_downstream', NSPROTask.getValue('speed')); // to CE from telco
                newCircuit.setValue('bandwidth_upstream', NSPROTask.getValue('speed')); // from CE to telco
                newCircuit.setValue('x_g_sonc_ns_pro_circuit_speed', NSPROTask.getValue('speed'));
                newCircuit.setValue('x_g_sonc_ns_pro_cir', NSPROTask.getValue('speed'));
                newCircuit.setValue('x_g_sonc_ns_pro_point_of_presence', NSPROTask.getValue('assigned_pop'));
                newCircuit.setValue('x_g_sonc_ns_pro_host_ckt_type', NSPROTask.getElement('circuit.x_g_sonc_ns_pro_host_ckt_type').toString());
                newCircuit.setValue('x_g_sonc_ns_pro_network_request', NSPROTask.getValue('telco_order'));
                newCircuit.setValue('x_g_sonc_ns_pro_status', 'pending'); // pending install
                newCircuit.setValue('install_status', 4);
                var newRcdId = newCircuit.insert();
                response.circuitSysID = newRcdId;
                response.circuitID = newCircuitNumber;
                response.message = "Temporary Circuit Created: " + newCircuitNumber;
            } else {
                response.message = "Error Occured in x_g_sonc_ns_pro.circuit.createTemporaryCiruit() the Task ID " + taskSysID + " was not found";
            }

        } catch (ex) {
            response.message = "Error Occured in x_g_sonc_ns_pro.circuit.createTemporaryCiruit() " + ex.toString();
        }
        return response;
    },
    removeLocalCircuits: function(localCircuits) {
        var errorString;
        var response = {};

        try {
            if (!localCircuits) {
                throw new IllegalArgumentException("localCircuits is a required parameter");
            }
            var circuitsArray = localCircuits.split(",");

            if (circuitsArray.length < 1) {
                throw new GenericException("one or more circuits must be selected");
            }
            gs.info('circuit array length is: ' + circuitsArray.length);
            for (var i = 0; i < circuitsArray.length; i++) {
                var circuitRecord = new GlideRecord(NSPROConstants.TABLES.CIRCUITS);
                circuitRecord.addQuery('sys_id', circuitsArray[i]);
                circuitRecord.query();
                if (circuitRecord.next()) {
                    circuitRecord.deleteRecord();
                }

            }

            response.message = circuitsArray.length + " circuits were removed from local circuit";

        } catch (ex) {
            errorString = "Error Occured in x_g_sonc_ns_pro.circuit.removeLocalCircuits " + ex.toString();
            gs.info(errorString);
            response.message = errorString;
        }

        return response;
    },
    type: 'circuit'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>wbbusby</sys_created_by>
        <sys_created_on>2024-03-23 22:52:58</sys_created_on>
        <sys_id>160966fa478d8a10f4af2ad2e16d43fb</sys_id>
        <sys_mod_count>105</sys_mod_count>
        <sys_name>circuit</sys_name>
        <sys_package display_value="NS Pro" source="x_g_sonc_ns_pro">b5683ae81b157110824752c1604bcbc0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</sys_scope>
        <sys_update_name>sys_script_include_160966fa478d8a10f4af2ad2e16d43fb</sys_update_name>
        <sys_updated_by>admglfry</sys_updated_by>
        <sys_updated_on>2024-10-18 19:40:55</sys_updated_on>
    </sys_script_include>
</record_update>
