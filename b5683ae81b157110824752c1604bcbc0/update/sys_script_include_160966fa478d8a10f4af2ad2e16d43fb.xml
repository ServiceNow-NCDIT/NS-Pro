<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_g_sonc_ns_pro.circuit</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>circuit</name>
        <script><![CDATA[var circuit = Class.create();
circuit.prototype = {
    initialize: function() {
        this.debug = true;
    },

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    timestamp: function() {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return new GlideDateTime().getNumericValue();
    },
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getDistance2Point: function(lat1, lon1, lat2, lon2) {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
        // calculates distance between two points using the Haversine formula.
        var LogPrefix = "getDistance2Point ";
        if (this.debug) gs.info(this.timestamp() + LogPrefix + " called, lat1 = " + lat1.toString() + ", lon1 = " + lon1.toString() + ", lat2 = " + lat2.toString() + ", lon2 = " + lon2.toString());
        var Rkm = 6371; // Radius of the earth in km
        var dLat = (lat2 - lat1) * (Math.PI / 180);
        var dLon = (lon2 - lon1) * (Math.PI / 180);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = Rkm * c; // Distance in km
		if (this.debug) gs.info(this.timestamp() + LogPrefix + ' returning ' + d);
        return d;
    },
	
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getHostPort : function (NSProTask) {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        var LogPrefix = " circuit().getHostPort --> ";

        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for task ' + NSProTask.number);
		if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for network_service_category ' + NSProTask.network_service_category);
		// is this best effort?
		if (NSProTask.network_service_category == 'best_effort') {
			if (this.debug) gs.info(this.timestamp() + LogPrefix + ' for best_effort network_service_category');
			// return host circuit dummy record instructing use of firewall
			//Per Keith - us the Agency Code from the site Record and Firewall
			//Example DOT Firewall.  If the Site Record does not have the Agency Code Populated use  Agency Firewall
			var bestEffortResponse = "Agency Firewall";
			if(NSProTask.site.x_g_sonc_ns_pro_agency){
				bestEffortResponse = bestEffortResponse.replace("Agency", NSProTask.site.x_g_sonc_ns_pro_agency.abbreviation.toString());
			}

			var hostCircuit = {};
			hostCircuit.x_g_sonc_ns_pro_pop_pe_interface = bestEffortResponse;
			hostCircuit.pop = bestEffortResponse;
			hostCircuit.pop_dv = bestEffortResponse;
			hostCircuit.pe_router = bestEffortResponse;
			hostCircuit.pe_router_dv = bestEffortResponse;
			
			return JSON.stringify(hostCircuit);
		}
		
		// execute this for guaranteed service
		if (this.debug) gs.info(this.timestamp() + LogPrefix + ' for guaranteed network_service_category');
		// get provider record
		var grProvider = new GlideRecord('x_g_sonc_ns_pro_telco_provider');
		var hostCircuits = this.getHostCircuitsForProvider(NSProTask.telco_provider); // retrieve an array of host circuit records
		var hostsWithCapacity = [];
		// identify circuits with capacity and fewer than 100 sites per circuit
		if (hostCircuits.length == 0) {
			gs.addErrorMessage('No host circuits returned for provider. Please select a new provider and try again.');
		}
		else {
			if (this.debug) gs.info(this.timestamp() + LogPrefix + 'getHostCircuitsForProvider returned ' + hostCircuits.length + ' circuits');
			for (i = 0; i < hostCircuits.length; i++) {
				if (this.debug) gs.info(this.timestamp() + LogPrefix + 'Checking capacity of ' + hostCircuits[i].circuit_id + ' with avail capacity of ' + hostCircuits[i].available_capacity + ' and site_count ' + hostCircuits[i].site_count);
				if (hostCircuits[i].available_capacity - parseInt(NSProTask.speed) > 0 && hostCircuits[i].site_count < 100) {
					if (this.debug) gs.info(this.timestamp() + LogPrefix + 'pushing ' + hostCircuits[i].circuit_id + ' to hostsWithCapacity');
					hostsWithCapacity.push(hostCircuits[i]);
				}
			}
			var closestCircuit = this.getClosestCircuit(NSProTask, hostsWithCapacity);
			NSProTask.circuit = closestCircuit.sys_id;
			NSProTask.update();
			gs.addErrorMessage('Closest circuit is ' + JSON.stringify(closestCircuit));
			return JSON.stringify(closestCircuit);
		}
		return; // null, could not find a closest circuit
		
    },	
	
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getHostCircuitsForProvider : function (provider) {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        var LogPrefix = " circuit().getHostForProvider --> ";

        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for provider ' + provider);
		
		var hostCircuits = [];
		var queryStr = 'x_g_sonc_ns_pro_host_ckt=true^x_g_sonc_ns_pro_circuit_typeINase,p2p_ase,me,p2p_me^install_statusIN1,4^x_g_sonc_ns_pro_telco_provider=' + provider;
		var gr = new GlideRecord('cmdb_ci_network_circuit');
		gr.addEncodedQuery(queryStr);
		gr.query();
		while (gr.next()) {
			if (this.debug) gs.info(this.timestamp() + LogPrefix + 'found host circuit ' + gr.name);
			var hostCircuit = {};
			hostCircuit.sys_id = gr.getUniqueValue();
			hostCircuit.circuit_id = gr.getValue('name');
			hostCircuit.available_capacity = gr.getValue('x_g_sonc_ns_pro_available_capacity');
			hostCircuit.site_count = gr.getValue('x_g_sonc_ns_pro_site_count');
			hostCircuit.pe_host_circuit_id = gr.getValue('x_g_sonc_ns_pro_pe_host_circuit_id');
			hostCircuit.x_g_sonc_ns_pro_pop_pe_interface = gr.x_g_sonc_ns_pro_pop_pe_interface.toString();
			hostCircuit.circuit_type = gr.getValue('x_g_sonc_ns_pro_circuit_type');
			hostCircuit.circuit_status = gr.getValue('x_g_sonc_ns_pro_status');
			hostCircuit.circuit_speed = gr.getValue('x_g_sonc_ns_pro_circuit_speed');
			hostCircuit.pop = gr.getValue('x_g_sonc_ns_pro_point_of_presence');
			hostCircuit.pop_dv = gr.getDisplayValue('x_g_sonc_ns_pro_point_of_presence');
			hostCircuit.telco_provider = gr.getValue('x_g_sonc_ns_pro_telco_provider');
			hostCircuit.telco_provider_dv = gr.getDisplayValue('x_g_sonc_ns_pro_telco_provider');
			hostCircuit.pe_router = gr.getValue('x_g_sonc_ns_pro_pe_router');
			hostCircuit.pe_router_dv = gr.getDisplayValue('x_g_sonc_ns_pro_pe_router');
			hostCircuits.push(hostCircuit);
		}
		// if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning host circuits ' + JSON.stringify(hostCircuits));
		return hostCircuits; // null = no hostCircuits

    },	

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getClosestCircuit : function (NSProTask, hostsWithCapacity) {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        var LogPrefix = " circuit().getClosestCircuits --> ";

        if (this.debug) gs.info(this.timestamp() + LogPrefix + ' executing for task ' + NSProTask.number);
		
		var locLat = NSProTask.location.latitude;
		var locLon = NSProTask.location.longitude;
		var closestDist = 9999; // artificially high so even the first distance comparison will be closer
		// var closestCircuit = hostsWithCapacity[0]; // just to set a default to begin comparisons against for closest circuit
		var closestCircuit;
		for (i = 0; i < hostsWithCapacity.length; i++) {
			if (this.debug) gs.info(this.timestamp() + LogPrefix + 'hostsWithCapacity[' + i + '] circuit = ' + hostsWithCapacity[i].circuit_id);
			var pop = hostsWithCapacity[i].pop;
			var grPop = new GlideRecord('x_g_sonc_ns_pro_point_of_presence');
			grPop.get(pop);
			if (this.debug) gs.info(this.timestamp() + LogPrefix + 'hostsWithCapacity[' + i + '] pop = ' + grPop.name);
			var dist = this.getDistance2Point(locLat, locLon, grPop.location.latitude, grPop.location.longitude);
			if (this.debug) gs.info(this.timestamp() + LogPrefix + hostsWithCapacity[i].circuit_id + ' dist = ' + dist + '. Closest dist = ' + closestDist);
			if (dist < closestDist) {
				closestCircuit = hostsWithCapacity[i];
				closestDist = dist;
			}
		}

		if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning closestCircuit ' + JSON.stringify(closestCircuit));
		return closestCircuit;

    },	


    type: 'circuit'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>wbbusby</sys_created_by>
        <sys_created_on>2024-03-23 22:52:58</sys_created_on>
        <sys_id>160966fa478d8a10f4af2ad2e16d43fb</sys_id>
        <sys_mod_count>57</sys_mod_count>
        <sys_name>circuit</sys_name>
        <sys_package display_value="NS Pro" source="x_g_sonc_ns_pro">b5683ae81b157110824752c1604bcbc0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</sys_scope>
        <sys_update_name>sys_script_include_160966fa478d8a10f4af2ad2e16d43fb</sys_update_name>
        <sys_updated_by>admglfry</sys_updated_by>
        <sys_updated_on>2024-07-31 17:41:12</sys_updated_on>
    </sys_script_include>
</record_update>
