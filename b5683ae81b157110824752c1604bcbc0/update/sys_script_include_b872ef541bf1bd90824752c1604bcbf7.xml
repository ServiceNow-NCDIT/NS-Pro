<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_g_sonc_ns_pro.core_nspro</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>core_nspro</name>
        <script><![CDATA[var core_nspro = Class.create();
core_nspro.prototype = {
    initialize: function() {},

    getDaysFromToday: function(days) {

        var gd = new GlideDate();
		gd.addDaysLocalTime(days);
		return gd.getDisplayValue();

    },
	
	getDaysFromDate: function(date, days) {
		
		var gd = new GlideDate();
		gd.setValue(date);
		gd.addDaysLocalTime(days);
	
		// gs.info('getDaysFromDate returning ' + gd);
		
		return gd;
		
	},
	
	isBeforeGracePeriod: function(new_date, created_on, request_type) {
		
		var nd = new GlideDate();		
		var td = new_date.split('/');
		gs.info('td = ' + td[2] + '-' + td[0] + '-' + td[1]);
		nd.setValue(td[2] + '-' + td[0] + '-' + td[1]);

		gs.info('core_nspro.isBeforeGracePeriod \nnew_date = ' + new_date + '\nnd = ' + nd + '\ncreated_on = ' + created_on + '\nrequest_type = ' + request_type);
		
		// calculate original due date based on request type and sys_created on
		var delta = 120; // default to 120 days for new services, 90 for changes
		if (request_type == 'Change') delta = 90;

		var due_date = new GlideDate();
		//gs.info('due_date set value = ' + this.getDaysFromDate(created_on, delta));
		due_date.setValue(this.getDaysFromDate(created_on, delta));
		//gs.info('due_date = ' + due_date);

		var grace_date = new GlideDate();
		//gs.info('grace_date set value = ' + this.getDaysFromDate(due_date, -15));

		grace_date.setValue(this.getDaysFromDate(due_date, -15)); // circuit due date is planned due date - 15 days
		//gs.info('grace_date = ' + grace_date);

		gs.info('core_nspro.isBeforeGracePeriod \ndue_date = ' + due_date + '\ngrace_date = ' + grace_date);
		
		if (new_date.getValue() < grace_date.getValue()) {
			gs.info('core_nspro.isBeforeGracePeriod returning true');
			return true;
		}
		else {
			gs.info('core_nspro.isBeforeGracePeriod returning false');
			return false;
		}

	},

    nsw2Util_selectPoPPEPort: function(provRcd) {
        /*
        Invoked by UI Action, this function will do:
            -- Get LATA using city by calling newt api (newt function calls https://localcallingguide.com ) (not any more)
            -- Gets ordered telco vendor name list based on teclo selection table (contracts)
            -- Gather port options for POP PE
            -- Makes port assignment based on algorithm.
            -- Updates provisioning record with appropriate info.
        Returns object with applicable info.
        */
        var thisFuncLogPrefix = "nsw2Util_selectPoPPEPort ";
        gs.info(thisFuncLogPrefix + " called with provRcd  " + provRcd.name);

        var pePortTable = "x_g_sonc_dit_nsw22_nsw2_pop_pe_port_circuits";

        var applog = new x_g_sonc_app_log.app_log();
        var log = {};
        log.app = 'NSPro';
        log.subroutine = 'nsw2Util_selectPoPPEPort';
        log.severity = 4;
        log.message = 'nsw2Util_selectPoPPEPort called with provRcd ' + provRcd.name;
        applog.log(JSON.stringify(log));

        var returnObject = {
            status: "",
            message: "",
            pop: "",
            pe: "",
            pePort: "",
            telcoName: ""
        };
        var lataStatus = "";
        var telcoStatus = "";
        var pePortStatus = "";
        var notes4pr = "PoP PE port selection requested.";
        // =========================================================================================
        // Get Pop distances
        // We are replacing Get LATA with a method of selecting the pop by distance
        // =========================================================================================
        var popsByDistance = [];
        //popsByDistance = this.nsw2Util_orderPopsClosest(34.9493327, -78.7572291); // test using site 20014
        // 07/13/22 if this is a move, then use new location lat/long
        // 07/26/22 re-factor check for location
        // if (provRcd.request_type == 'Relocate') { 
        //     if (gs.nil(provRcd.location) || provRcd.location == "") {
        //         gs.info(thisFuncLogPrefix + "Move-request ERROR: Expected location value to be set");
        //         returnObject.status = "MOVEERROR";
        //         returnObject.message = "Move-request ERROR: Expected location value to be set";
        //         return returnObject;
        //     } else {
        //         gs.info(thisFuncLogPrefix + "Using move-to location for finding pop distance, lat/long " +
        //             provRcd.location.latitude + "/" + provRcd.location.longitude);
        //         popsByDistance = this.nsw2Util_orderPopsClosest(provRcd.location.latitude, provRcd.location.longitude);
        //     }
        // } else { // req type other than move
        //     popsByDistance = this.nsw2Util_orderPopsClosest(provRcd.site.location.latitude, provRcd.site.location.longitude);
        // }

        gs.info('lat = ' + provRcd.site.location.latitude + ' longitude = ' + provRcd.site.location.longitude);

        popsByDistance = this.nsw2Util_orderPopsClosest(provRcd.site.location.latitude, provRcd.site.location.longitude);

        popsByDistance.sort(function(a, b) {

            gs.info('returning a = ' + a.distanceKm + ' b = ' + b.distanceKm);

            return a.distanceKm - b.distanceKm;
        });
        global.JSUtil.logObject(popsByDistance, thisFuncLogPrefix + " ordered PoPs");
        gs.info(thisFuncLogPrefix + " closest PoP is siteId " + popsByDistance[0].popSiteId + ". " + popsByDistance[0].distanceMiles.toFixed(2) + " miles");
        gs.info(thisFuncLogPrefix + " next closest PoP is siteId " + popsByDistance[1].popSiteId + ". " + popsByDistance[1].distanceMiles.toFixed(2) + " miles");
        lataStatus = "OK";

        // new function to get a primary pe port
        // need to loop through all pops to find closest accaptable for primary
        for (var pindex = 0; pindex < popsByDistance.length; pindex++) {
            gs.info(thisFuncLogPrefix + " calling get pe function for primary pe port using pop " + popsByDistance[pindex].popSiteId);
            var priPePort = this.nsw2Util_getPEPort4PopWithProvRcd(provRcd, popsByDistance[pindex].popSiteId, ""); // 3rd parm: accept all telcos found
            if (priPePort.status == "OK") {
                global.JSUtil.logObject(priPePort, thisFuncLogPrefix + " primary pe port assignment function found this from call to nsw2Util_getPEPort4PopWithProvRcd");
                provRcd.assigned_pe_port = priPePort.popPePortSysId;
                provRcd.assigned_pe = priPePort.pe;
                //provRcd.setDisplayValue('assigned_pop_abbrev', priPePort.popAbbrev); //sprint 27 06/29/22 - error not allowd.
                provRcd.assigned_pop = priPePort.popAbbrev; //sprint 27 06/29/22 - also change prov rcd choice values to abbreviations.

                // should this be '3'?
                provRcd.state = 4; // remember there is a spelling error on this field. pe circuit assigned

                provRcd.telco_provider = priPePort.telcoName; // 02/24/22 - added to see if this is a good way to convey selected telco name for the uplink
                notes4pr = notes4pr + " Primary PE suggested as " + priPePort.pePort + ".";
                break; // stop looking
            } else {
                gs.error(thisFuncLogPrefix + " primary telco was not selected by call to nsw2Util_getPEPort4PopWithProvRcd at pop " + popsByDistance[pindex].popSiteId);
                // if we reach here and still no pePortOptions, then we need to look at other pops.
            }
        }

        // primary ok, see if we need another
        // if we have a need for redundancy (HA gold service), the find another pe port preferably at a different pop.
        if (provRcd.request_ha) {
            gs.info(thisFuncLogPrefix + " redundancy required. find another pe port. pop list has " + popsByDistance.length + " records.");
            // keep trying pops 2-n until we find one
            for (var aindex = 0; aindex < popsByDistance.length; aindex++) {
                // skip pri pe pop
                if (popsByDistance[aindex].popSiteId != priPePort.pop) {
                    gs.info(thisFuncLogPrefix + " calling get pe function for alternate pe port using pop " + popsByDistance[aindex].popSiteId);
                    var secPePort = this.nsw2Util_getPEPort4PopWithProvRcd(provRcd, popsByDistance[aindex].popSiteId, priPePort.telcoName); // ignore telco from primary
                    if (secPePort.status == "OK") {
                        global.JSUtil.logObject(secPePort, thisFuncLogPrefix +
                            " alternate pe port assignment function found this from call to nsw2Util_getPEPort4PopWithProvRcd at pop " +
                            popsByDistance[aindex].popSiteId);

                        // commented out secondary telco info
                        // provRcd.assigned_pe_port_secondary = secPePort.popPePortSysId;
                        // provRcd.assigned_pe_secondary = secPePort.pe;
                        // //provRcd.setDisplayValue('assigned_pop_abbrev', secPePort.popAbbrev); //sprint 27 06/29/22 - error not allowd.
                        // provRcd.assigned_pop_abbrev_secondary = secPePort.popAbbrev; //sprint 27 06/29/22 - also change prov rcd choice values to abbreviations. fix 7/29/22
                        // provRcd.telco_name_2 = secPePort.telcoName; // 02/24/22 - added to see if this is a good way to convey selected telco name for the uplink
                        // gs.info(thisFuncLogPrefix + " setting alternate pop pe port to sys_id " + secPePort.popPePortSysId + ", " + secPePort.pePort);
                        // notes4pr = notes4pr + " Secondary PE suggested as " + secPePort.pePort + ".";
                        break;
                    } else {
                        gs.error(thisFuncLogPrefix + " redundant telco was not selected by call to nsw2Util_getPEPort4PopWithProvRcd at pop " + popsByDistance[aindex].popSiteId);
                        // if we reach here and still no pePortOptions, then we need to look at other pops.
                    }
                } else {
                    gs.info(thisFuncLogPrefix + " skipping pri pop " + priPePort.pop + " for alternate port selection.");
                }
            }
        } else {
            gs.info(thisFuncLogPrefix + " redundancy not required. skipping find another pe port");
        }
        provRcd.work_notes = notes4pr;
        provRcd.update();

        returnObject = priPePort;

        return returnObject;
    },

    nsw2Util_orderPopsClosest: function(lat, longitude) {
        /*
        If provided with a simple list of pop site ids, this function will return
        a list of pop distances ordered closest to furthest from the supplied geo point.
        If the popList is empty, all pop sites are returned.

        11/01/22 pretty code.
        */


        var applog = new x_g_sonc_app_log.app_log();
        var log = {};
        log.app = 'NSPro';
        log.subroutine = 'nsw2Util_orderPopsClosest';
        log.severity = 4;
        log.message = "nsw2Util_orderPopsClosest called with provRcd lat " + lat + ' and longitude ' + longitude;
        applog.log(JSON.stringify(log));


        var thisFuncLogPrefix = "nsw2Util_orderPopsClosest ";
        var orderedListOfPopsWithDistance = [];
        var matchPopList = false;
        var siteTable = "x_g_sonc_dit_nsw22_nsw2_sites";

        // added to compensate for popList apparently not being defined
        var popList = [];

        if (popList.length == 0) {
            gs.info(thisFuncLogPrefix + " called with empty popList, lat = " + lat.toString() + ", longitude = " + longitude.toString());
            //var dtest = this.nsw2Util_getDistance2Point(lat, longitude, 35.0525994, -78.8903642);
            //var dtestMiles = dtest * 0.62137; // multiply the number of kilometers by 0.62137.
            //gs.info(thisFuncLogPrefix + "TEST distance to FAY is " + dtest.toFixed(2) + " km, " + dtestMiles.toFixed(2) + " miles");
        } else {
            gs.info(thisFuncLogPrefix + " called with popList length = " + popList.length + ", lat = " + lat.toString() + ", longitude = " + longitude.toString());
            matchPopList = true;
        }

        // site_typeSTARTSWITHpop^nameLIKEpop
        var pePopQuery = "site_typeSTARTSWITHpop^nameLIKENGN";
        gs.info(thisFuncLogPrefix + " searching for pop sites with '" + pePopQuery);

        var popSiteGR = new GlideRecord(siteTable);
        popSiteGR.addEncodedQuery(pePopQuery);
        popSiteGR.query();

        while (popSiteGR.next()) {
            var matchesList = false;
            if (matchPopList) {
                // see if the site id is in the list passed to us				
                for (var index = 0; index < popList.length; index++) {
                    if (popSiteGR.site_id == popList[index]) {
                        matchesList = true;
                    }
                }
            } else {
                matchesList = true;
            }
            if (matchesList) {
                // get lat, longitude and find distance for this pop
                var popDistanceRcd = {
                    popName: "",
                    popSiteId: "",
                    distanceKm: 0.0,
                    distanceMiles: 0.0
                };
                popDistanceRcd.popSiteId = popSiteGR.getValue('site_id');
                popDistanceRcd.popName = popSiteGR.getValue('site_name');
                popDistanceRcd.distanceKm = this.nsw2Util_getDistance2Point(lat, longitude, popSiteGR.location.latitude, popSiteGR.location.longitude);
                popDistanceRcd.distanceMiles = popDistanceRcd.distanceKm * 0.62137; // multiply the number of kilometers by 0.62137.
                orderedListOfPopsWithDistance.push(popDistanceRcd);
            }
        }

        return orderedListOfPopsWithDistance;
    },

    nsw2Util_getPEPort4PopWithProvRcd: function(provRcd, popSiteId, ignoreTelco) {
        /*
        Utility to find best pe port given a pop and provisioning record

        Input:
        provRcd = provisioning record for this activity. Used for 
            - logging the number and for 
            - getting zip for telco lookup and for
            - req_network_service_category to match pe ports
        ignoreTelco = used to ignore a telco such as when the call is for a redundanct connection
        and the caller knows it wants to avoid a particular service_for telco becuase it was used
        for the primary connection.

        (new 01/25/22 rw) - add check for high speed, if => 250Mbps, then look for TenGig ports only.
        (new 09/26/22 rw) - check up front for Best effort or Guaranteed:
          provRcd.req_network_service_category == '1' is Guaranteed, 2 is BE
        */


        var applog = new x_g_sonc_app_log.app_log();
        var log = {};
        log.app = 'NSPro';
        log.subroutine = 'nsw2Util_getPEPort4PopWithProvRcd';
        log.severity = 4;
        log.message = "nsw2Util_getPEPort4PopWithProvRcd called with provRcd  " + global.JSON.stringify(provRcd) + " popSiteId " + popSiteId + 'and ignoreTelco ' + ignoreTelco;
        applog.log(JSON.stringify(log));

        var thisFuncLogPrefix = "nsw2Util_getPEPort4PopWithProvRcd";
        gs.info(thisFuncLogPrefix + " called with provRcd  " + provRcd.name + ", pop site_id " + popSiteId);

        var pePortTable = "x_g_sonc_dit_nsw22_nsw2_pop_pe_port_circuits";
        var returnObject = {
            status: "",
            message: "",
            pop: "",
            popAbbrev: "",
            pe: "",
            pePort: "",
            telcoName: "",
            popPePortSysId: ""
        };
        var lataStatus = "";
        var telcoStatus = "";
        var pePortStatus = "";
        var port2Use = {};
        var svcCatIsGuaranteed = false;
        var svcCatIsBE = false;
        var svcCat = "";

        // need to rework this logic for definition of svc_type to represent guaranteed and best effort definitions
        if (provRcd.service_definition.svc_ha_category == 'Gold' || provRcd.service_definition.svc_ha_category == 'Silver') {
			svcCatIsGuaranteed = true;
			svcCatIsBE = false;
			svcCat = "Guaranteed"; // 10/28/22 fix spelling
			gs.info(thisFuncLogPrefix + " provRcd " + provRcd.name + " service type is " + provRcd.service_type);
		}
           
        else {
            svcCatIsGuaranteed = false;
            svcCatIsBE = true;
            svcCat = "Best effort";
            gs.info(thisFuncLogPrefix + " provRcd " + provRcd.name + " service type is " + provRcd.service_type);
        }

        // =========================================================================================
        // Get Telcos using provRcd zip
        // =========================================================================================
        gs.info(thisFuncLogPrefix + " calling for telco selection by zip");
        // get telco provider list 
		
		// orig : var telcoProviderList = this.nsw2Util_selectTelcoByZip(provRcd.zip, svcCat);
        var telcoProviderList = this.nsw2Util_selectTelcoByZip(provRcd.site.location.zip, svcCat);
        if (telcoProviderList.length > 0) {
            gs.info(thisFuncLogPrefix + " primary telco is: " + telcoProviderList[0]);
            returnObject.telcoName = telcoProviderList[0];
            telcoStatus = "OK";
            //returnObject.telcoName = telcoProviderList[0];
        } else {
            gs.error(thisFuncLogPrefix + " could not determine primary telco for " + provRcd.name);
            returnObject.message = returnObject.message + "; " + thisFuncLogPrefix + " could not determine primary telco for " + provRcd.number;
            returnObject.status = "TELCOERR";
        }

        if (svcCatIsGuaranteed) {
            if (telcoStatus == "OK") {
                // =========================================================================================
                // Get Primary PE port
                // =========================================================================================
                // get pop pe port records for pe prefix and telco match
                gs.info(thisFuncLogPrefix + " working on pe port assignment... " + telcoProviderList.length + " telco options");
                var pePortOptions = [];
                var telcoOptionNumber = 0;
                var primaryPePortSet = false;
                // determine service type for pe port search search
                // still need to confirm this method.
                var pe_circuit_type = "";

                // rework
                // if (provRcd.req_network_service_category == '1') {
                pe_circuit_type = 'IN1,3'; // Metro Ethernet or ASE
                // } else {
                //     pe_circuit_type = 'IN2,4'; // Metro Ethernet or ASE dedicated, will be used for best effort.
                // }

                // first get a pe port using the passed in pop.
                while (pePortOptions.length == 0 && telcoOptionNumber < telcoProviderList.length) {
                    // check to see if we should skip a telco
                    if (ignoreTelco != "") {
                        if (telcoProviderList[telcoOptionNumber] == ignoreTelco) {
                            gs.info(thisFuncLogPrefix + "ignoring telco " + ignoreTelco + " at callers request.");
                            telcoOptionNumber = telcoOptionNumber + 1; // be careful, without this you have an infinite loop.
                            continue;
                        }
                    }
                    var pePortQuery = "nsw_site_id=" + popSiteId +
                        "^service_for=" + telcoProviderList[telcoOptionNumber] +
                        "^pe_circuit_type" + pe_circuit_type +
                        "^status=1"; // status Active
                    // 01/25/22 rw, check for high speed and set query; depends on requested_speed in provRcd
                    // 01/26/22 rw, add force low speed to gigE at Mark's direction.
                    var provRcdSpeed = provRcd.getValue('requested_speed');
                    if (provRcdSpeed < 250000000.0) {
                        gs.info(thisFuncLogPrefix + " high speed search for tenGigE is NOT active for " + provRcd.name);
                        if (provRcdSpeed < 100000000.0) {
                            gs.info(thisFuncLogPrefix + " low speed search for gigE is ACTIVE for " + provRcd.name);
                            pePortQuery = pePortQuery + "^pe_circuit_cir=1000000000";
                        }
                    } else {
                        gs.info(thisFuncLogPrefix + " high speed search for tenGigE is ACTIVE for " + provRcd.name);
                        pePortQuery = pePortQuery + "^pe_circuit_cir=10000000000";
                    }
                    gs.info(thisFuncLogPrefix + " searching for pe with '" + pePortQuery + "' for " + provRcd.name);

                    var poppeGR = new GlideRecord(pePortTable);
                    poppeGR.addEncodedQuery(pePortQuery);
                    poppeGR.query();

                    while (poppeGR.next()) {
                        var pePortCandidateObj = {
                            sys_id: "",
                            name: "",
                            pe: "",
                            popAbbrev: "",
                            cir_subscription_rate: 0.0,
                            util_pct: 0.0,
                            endpoint_count: 0
                        };
                        pePortCandidateObj.sys_id = poppeGR.getValue('sys_id');
                        pePortCandidateObj.name = poppeGR.getValue('name');
                        pePortCandidateObj.pe = poppeGR.getValue('pe_router');
                        pePortCandidateObj.popAbbrev = poppeGR.getValue('point_of_presence');
                        pePortCandidateObj.cir_subscription_rate = poppeGR.getValue('cir_subscription_rate');
                        pePortCandidateObj.util_pct = poppeGR.getValue('util_pct');
                        pePortCandidateObj.endpoint_count = poppeGR.getValue('endpoint_count');
                        pePortOptions.push(pePortCandidateObj);
                        gs.info(thisFuncLogPrefix + " adding to pePortOptions: " + pePortCandidateObj.name);
                    }
                    global.JSUtil.logObject(pePortOptions, thisFuncLogPrefix + " pePortOptions before call to nsw2Util_selectBestPEPortFromList");
                    if (pePortOptions.length > 0) {
                        // we have port(s)
                        gs.info(thisFuncLogPrefix + " " + pePortOptions.length + " pe port options available at pop " + popSiteId + " for " + provRcd.name);
                        port2Use = this.nsw2Util_selectBestPEPortFromList(pePortOptions);
                        if (port2Use.status == "BESTPORTFOUND") {
                            gs.info(thisFuncLogPrefix + " best port assigned for pop " + popSiteId + " for provRcd " + provRcd.name);
                            returnObject.pePort = port2Use.bestPort.name;
                            returnObject.telcoName = telcoProviderList[telcoOptionNumber];
                            returnObject.pop = popSiteId;
                            returnObject.popAbbrev = port2Use.bestPort.popAbbrev;
                            returnObject.popPePortSysId = port2Use.bestPort.sys_id;
                            returnObject.pe = port2Use.bestPort.pe;
                            returnObject.message = "best port assigned at pop " + popSiteId + ", " + port2Use.bestPort.name + " for provRcd " + provRcd.name;
                            returnObject.status = "OK";
                            primaryPePortSet = true;
                        } else {
                            gs.error(thisFuncLogPrefix + " best pe port was not determined at pop site " + popSiteId);
                            returnObject.status = "NOBESTPORT";
                        }
                    } else {
                        gs.warn(thisFuncLogPrefix + " no PE Ports found for telco option " + telcoProviderList[telcoOptionNumber] +
                            " at pop " + popSiteId + " for " + provRcd.name);
                        telcoOptionNumber = telcoOptionNumber + 1;
                    }
                }
                // if we reach here and still no pePortOptions, then we need to look at other pops.
                if (!primaryPePortSet) {
                    gs.warn(thisFuncLogPrefix + " PE port was not determined for " + provRcd.name + ", pop " + popSiteId);
                    returnObject.status = "NOPORT4POP";
                }
            } else {
                gs.warn(thisFuncLogPrefix + " skipping PE port assignment due to telco error.");
                returnObject.status = "TELCOERR";
            }
        } else {
            // 09/26/22: service cat is Best effort, so instead of PE, tell user to get a firewall connection instead.
            gs.warn(thisFuncLogPrefix + " skipping PE port assignment due to best effort service - user instructed to use firewall");

            //returnObject.status = "USEFIREWALL";
            //returnObject.pePort = port2Use.bestPort.name;
            returnObject.telcoName = telcoProviderList[0];
            returnObject.pop = "Use Firewall";
            //returnObject.popAbbrev = port2Use.bestPort.popAbbrev;
            //returnObject.popPePortSysId = port2Use.bestPort.sys_id;
            returnObject.pe = "Firewall";
            returnObject.status = "OK";
            returnObject.message = "Use firewall for best effort service for provRcd " + provRcd.name;
        }
        return returnObject;
    },

    nsw2Util_getDistance2Point: function(lat1, lon1, lat2, lon2) {


        var applog = new x_g_sonc_app_log.app_log();
        var log = {};
        log.app = 'NSPro';
        log.subroutine = 'nsw2Util_getDistance2Point';
        log.severity = 4;
        log.message = "nsw2Util_getDistance2Point called with lat1  " + lat1 + " lon1 " + lon1 + 'and lat2 ' + lat2 + 'and lon2 ' + lon2;
        applog.log(JSON.stringify(log));

        // calculates distance between two points using the Haversine formula.
        var thisFuncLogPrefix = "nsw2Util_getDistance2Point ";
        //gs.info(thisFuncLogPrefix + " called, lat1 = " + lat1.toString() + ", lon1 = " + lon1.toString() + ", lat2 = " + lat2.toString() + ", lon2 = " + lon2.toString());
        var Rkm = 6371; // Radius of the earth in km
        var dLat = (lat2 - lat1) * (Math.PI / 180);
        var dLon = (lon2 - lon1) * (Math.PI / 180);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = Rkm * c; // Distance in km

        return d;
    },

    nsw2Util_selectTelcoByZip: function(zip, svcCat) {
        /*
        Provides and ordered list of telco names using the telco selection table.
        09/26/22: mod to hanlde BE providers, too.
        */

        var applog = new x_g_sonc_app_log.app_log();
        var log = {};
        log.app = 'NSPro';
        log.subroutine = 'nsw2Util_selectTelcoByZip';
        log.severity = 4;
        log.message = "nsw2Util_selectTelcoByZip called with zip  " + zip + " svcCat " + svcCat;
        applog.log(JSON.stringify(log));

        var thisFuncLogPrefix = "nsw2Util_selectTelcoByZip ";
        var telcoTable = "x_g_sonc_dit_nsw22_telco_selection_criteria";
        var telcoProviderList = [];
        gs.info(thisFuncLogPrefix + " invoked with zip = " + zip + ", service category = " + svcCat);
        var telcoGR = new GlideRecord(telcoTable);
        telcoGR.addEncodedQuery("zip=" + zip);
        telcoGR.query();
        if (telcoGR.next()) {
            var vProvPri = "";
            if (svcCat == "Guaranteed") {
                gs.info(thisFuncLogPrefix + " found matching telco selection entry for " + zip + ", city: " + telcoGR.city +
                    ", pri1 = " + telcoGR['providerpriority1'] + ", pri2 = " + telcoGR['providerpriority2']);
                // take first (should be only) record and get ordered list of telco names
                vProvPri = "";
                gs.info(thisFuncLogPrefix + " provider count is " + telcoGR.providercount + ", last var is providerpriority" + telcoGR.providercount.toString());
                for (var i = 1; i <= telcoGR.providercount; i++) {
                    vProvPri = "providerpriority" + i.toString();
                    // gs.info(thisFuncLogPrefix + " pushing " + telcoGR[vProvPri] + " to provider list");
                    telcoProviderList.push(telcoGR.getValue(vProvPri));
                }
            } else if (svcCat == "Best effort") {
                gs.info(thisFuncLogPrefix + " found BE matching telco selection entry for " + zip + ", city: " + telcoGR.city +
                    ", pri1 = " + telcoGR['beproviderpriority1'] + ", pri2 = " + telcoGR['beproviderpriority2']);
                // take first (should be only) record and get ordered list of telco names
                vProvPri = "";
                gs.info(thisFuncLogPrefix + " provider count is " + telcoGR.beprovidercount + ", last var is beproviderpriority" + telcoGR.beprovidercount.toString());
                for (var i = 1; i <= telcoGR.beprovidercount; i++) {
                    vProvPri = "beproviderpriority" + i.toString();
                    // gs.info(thisFuncLogPrefix + " pushing " + telcoGR[vProvPri] + " to provider list");
                    telcoProviderList.push(telcoGR.getValue(vProvPri));
                }
            }
        } else {
            gs.error(thisFuncLogPrefix + " zip " + zip + " missing from telco selection table");
        }
        return telcoProviderList;
    },

    type: 'core_nspro'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>wbbusby</sys_created_by>
        <sys_created_on>2023-10-06 19:14:59</sys_created_on>
        <sys_id>b872ef541bf1bd90824752c1604bcbf7</sys_id>
        <sys_mod_count>98</sys_mod_count>
        <sys_name>core_nspro</sys_name>
        <sys_package display_value="NS Pro" source="x_g_sonc_ns_pro">b5683ae81b157110824752c1604bcbc0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</sys_scope>
        <sys_update_name>sys_script_include_b872ef541bf1bd90824752c1604bcbf7</sys_update_name>
        <sys_updated_by>wbbusby</sys_updated_by>
        <sys_updated_on>2023-11-27 06:31:32</sys_updated_on>
    </sys_script_include>
</record_update>
