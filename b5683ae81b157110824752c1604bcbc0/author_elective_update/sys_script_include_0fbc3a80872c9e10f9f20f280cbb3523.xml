<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="DELETE">
        <access>public</access>
        <active>true</active>
        <api_name>x_g_sonc_ns_pro.debugTesting</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>debugTesting</name>
        <script><![CDATA[var debugTesting = Class.create();
debugTesting.prototype = {
    initialize: function() {
		this.debug = true;
    },
   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DefineReqCpe: function(NSProTask) {
        var LogPrefix = " DefineReqCpe --> ";
        var serviceTable = "x_g_sonc_ns_pro_service_definition";
        var accumulateWorkNotes = "";
        var modelsRequired = [];
        var detailedRequiredCpeInventory = []; // 10/20/22 we are going to need to provide detail to the FS task.
        // it might be better to just make a related table of cpe requirements. would simplify everything.
        /*
        Driven by UI action.
        This function is meant to determine if there exists enough of a particular model in stock to fullfill 
        a provisioning function and then allocate models to the prov record.

        10/10/22 - Extended this function to handle LAN CPE, too.
        Provisioning rcd now allow for entry of the number of required LAN switch types. We will use that data to check for LAN switch
        CPE in stock.

        */
        var returnObject = {
            status: "",
            message: "",
            cpe: {
                model: "",
                available: false,
                inStockCount: 0
            }
        };
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "called for " + NSProTask.number);

        /* This first section needs to be done if this is for WAN provisioning with CPE
            if it is for something other than WAN, then we only need to concern ourselves with that part.
            See checks below. 
        */

        /* --------------------------------------------------------------------------------
            DO WAN RELATED CPE WORK
            10/18/22 Since we're combining wan and lan, only do this wan part if
            wan_cpe_ports_required is not blank or 0
        -----------------------------------------------------------------------------------
        */
        if (NSProTask.wan_cpe_ports_required != '' && NSProTask.wan_cpe_ports_required != 0 && NSProTask.wan_cpe_ports_required != null) {

            var defaultMedia = "mediaANYTHING";
            var mediaSearch = defaultMedia;
            var cpeQty = 1;

            // lets first find out what model(s) do we need based on the provisioning activity
            // We're going to have a process where the network analyst explicitly agrees and sets the assigned WAN service.
            var provInputValid = true;
            if (NSProTask.assigned_wan_service == null || NSProTask.assigned_wan_service == '') {
                provInputValid = false;
                returnObject.message = returnObject.message + " WAN service not explicitly set.";
            } else {
                // if we do have this wan service, then look it up and use this service code.
                var svcGR = new GlideRecord(serviceTable);
                assSvcRcdFound = svcGR.get(NSProTask.assigned_wan_service);
                if (assSvcRcdFound) {
                    var assSvcCode = svcGR.getValue('svc_code');
                    // we only care about media for broadband to determine LTE4G or not.
                    if (assSvcCode.charAt(0) == 'B') {
                        // then we need to know the media requested for the provisioning activity
                        if (NSProTask.wan_circuit_type_jack == null || NSProTask.wan_circuit_type_jack == '') {
                            provInputValid = false;
                            returnObject.message = returnObject.message + " WAN Circuit type jack undefined.";
                        } else {
                            mediaSearch = "media=" + NSProTask.wan_circuit_type_jack;
                        }
                    } else {
                        //
                        // TODO needed? will this order 4 when both circuits are processed? Commented out until verified
                        //
                        // if (assSvcCode.charAt(0) == 'G') {
                        //     // this is HA, so cpe qty = 2
                        //     cpeQty = 2;
                        // }
                    }
                }
            }
            if (NSProTask.wan_cpe_ports_required < 1 || NSProTask.wan_cpe_ports_required == '') {
                provInputValid = false;
                returnObject.message = returnObject.message + " required ports unknown.";
            }

            // the search will be based on the following criteria
            // svc_code, media, number of ports required.
            // ex: mediaANYTHING^cpe_port_range_low<=2^cpe_port_range_high>=2^svc_code=SEW5M
            // First check that we have the needed criteria
            if (provInputValid) {
                // ok, we have all of the input we need to proceed
                // lets find the ordered, preferred cpe list for the service.
                var cpeModelReqSearch = mediaSearch + "^svc_code=" + assSvcCode +
                    "^cpe_port_range_low<=" + NSProTask.wan_cpe_ports_required.toString() +
                    "^cpe_port_range_high>=" + NSProTask.wan_cpe_ports_required.toString();

                var cpeModelOptions = this.getSvcCpeModelsBySearch(cpeModelReqSearch);

                if (this.debug) gs.info(this.timestamp() + LogPrefix + "determined model options are: " + JSON.stringify(cpeModelOptions));
                accumulateWorkNotes = "CPE Requirements Definition:\nModel options are " + cpeModelOptions.join() + "\n";

                if (cpeModelOptions.length > 0) {
                    // now that we know what models we can use and in what preferred order,
                    // lets verify that we indeed have the quantity we need in stock.
                    var cpeEquipmentVerified = false;
                    // we need to make this loop through the options
                    for (var cpei = 0; cpei < cpeModelOptions.length; cpei++) {
                        var verifyCpeResp = this.verifyCpe(cpeModelOptions[cpei], cpeQty, 'WAN');
                        if (this.debug) gs.info(this.timestamp() + LogPrefix + "verifyCpe response was " + JSON.stringify(verifyCpeResp));
                        if (verifyCpeResp.status == 'OK' && verifyCpeResp.cpe.inStockCount >= cpeQty) {
                            // set NSProTask
                            cpeEquipmentVerified = true;
                            // var modelsRequired = []; // move this to top, global
                            for (var i = 0; i < cpeQty; i++) {
                                modelsRequired.push(verifyCpeResp.cpe.model);
                                detailedRequiredCpeInventory.push(verifyCpeResp); // 10/20/22 get details for cpe needs
                            }
                            // NSProTask.cpe_models_required = modelsRequired.join(); // move this below to handle lan models, too
                            // set a work note in the prov rcd
                            accumulateWorkNotes = accumulateWorkNotes + "Required WAN models:\n" + modelsRequired.join() + "\nVerified quantity in stock\n";
                            // NSProTask.provisoning_state = "6"; //CPE requirements defined  - moved to UI action
                            returnObject = verifyCpeResp;
                            break;
                        }
                    }
                    // if we reach here with no good model verification, alert the analyst.
                    if (!cpeEquipmentVerified) {
                        returnObject.status = "NOCPEINSTOCK";
                        returnObject.message = "No acceptable cpe models found available in stock. Unable to continue provisioning activity.";
                        gs.error(LogPrefix + returnObject.message + " for " + NSProTask.number);
                        accumulateWorkNotes = accumulateWorkNotes + "CPE: " + returnObject.message + "\n";
                        NSProTask.setValue('cpe_models_required', '');
                    }
                } else {
                    returnObject.status = "NOCPEOPTIONS";
                    returnObject.message = "No cpe models determined from service definition table search";
                    gs.error(this.timestamp() + LogPrefix + returnObject.message + " for " + NSProTask.number);
                    NSProTask.setValue('cpe_models_required', '');
                }
            } else {
                returnObject.status = "INPUTERROR";
                if (this.debug) gs.info(this.timestamp() + LogPrefix + "input error detected for " + NSProTask.number);
                NSProTask.setValue('cpe_models_required', '');
            }
        } else {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + "Skipping WAN CPE work since no ports required for " + NSProTask.number);
            returnObject.status = 'OK'
            returnObject.message = "No wan ports required."
        } // end do wan cpe work

        /* --------------------------------------------------------------------------------
            DO LAN RELATED CPE WORK
        -----------------------------------------------------------------------------------
        */
        // add call for lan cpe
        var cpeNeedsResp = this.verifyLANCpe(NSProTask);
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "cpeNeedsResp = " + JSON.stringify(cpeNeedsResp)) // lets see what we got 10/17/22
        // add more work_notes from lan cpe responses
        for (var crI = 0; crI < cpeNeedsResp.cpe.length; crI++) {
            modelsRequired.push(cpeNeedsResp.cpe[crI].cpe.model);
            accumulateWorkNotes = accumulateWorkNotes + "LAN CPE: " + cpeNeedsResp.cpe[crI].message + "\n";
            detailedRequiredCpeInventory.push(cpeNeedsResp.cpe[crI]);
        }

        if (accumulateWorkNotes != "") {
            NSProTask.work_notes = accumulateWorkNotes;
        }

        // gather all req cpe and add to list.
        NSProTask.cpe_models_required = modelsRequired.join()
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "Detailed cpe needs for prov activity are: " + JSON.stringify(detailedRequiredCpeInventory));
        NSProTask.detailed_cpe_needs = JSON.stringify(detailedRequiredCpeInventory);

        NSProTask.update();
        return returnObject;
    },
    getSvcCpeModelsBySearch: function(searchStr) {
        var LogPrefix = " getSvcCpeModelsBySearch --> ";
        var svcTable = "x_g_sonc_ns_pro_service_definition";
        /*
        This function returns a list of ordered cpe models for the service using 
        a given search string. 
        */
        var cpeModelList = [];
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "called with " + searchStr);

        var scGR = new GlideRecord(svcTable);
        scGR.addEncodedQuery(searchStr);
        scGR.query();
        if (scGR.next()) {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + "found svc record for cpe, " + scGR.getValue('sys_id') + ", " + scGR.getValue("svc_title"));
            for (var sindex = 1; sindex < 5; sindex++) {
                var svcCpeVarName = "cpe_model_" + sindex.toString();
                var cpeMod = scGR.getValue(svcCpeVarName);
                if (cpeMod != "" && cpeMod != null) {
                    cpeModelList.push(cpeMod);
                }
            }
        } else {
            gs.error(this.timestamp() + LogPrefix + "service definition record not found");
        }

        if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning cpeModelList of ' + cpeModelList);

        return cpeModelList;
    },
    type: 'debugTesting'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admglfry</sys_created_by>
        <sys_created_on>2024-09-05 10:55:15</sys_created_on>
        <sys_id>0fbc3a80872c9e10f9f20f280cbb3523</sys_id>
        <sys_mod_count>3</sys_mod_count>
        <sys_name>debugTesting</sys_name>
        <sys_package display_value="NS Pro" source="x_g_sonc_ns_pro">b5683ae81b157110824752c1604bcbc0</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</sys_scope>
        <sys_update_name>sys_script_include_0fbc3a80872c9e10f9f20f280cbb3523</sys_update_name>
        <sys_updated_by>admglfry</sys_updated_by>
        <sys_updated_on>2024-09-05 13:38:55</sys_updated_on>
    </sys_script_include>
    <sys_update_version action="INSERT_OR_UPDATE">
        <action>DELETE</action>
        <application display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</application>
        <file_path/>
        <instance_id>efe2cdc7db351c10bc8b7f693296192d</instance_id>
        <instance_name>ncgovappdev</instance_name>
        <name>sys_script_include_0fbc3a80872c9e10f9f20f280cbb3523</name>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;&lt;sys_script_include action="INSERT_OR_UPDATE"&gt;&lt;access&gt;public&lt;/access&gt;&lt;active&gt;true&lt;/active&gt;&lt;api_name&gt;x_g_sonc_ns_pro.debugTesting&lt;/api_name&gt;&lt;caller_access/&gt;&lt;client_callable&gt;false&lt;/client_callable&gt;&lt;description/&gt;&lt;name&gt;debugTesting&lt;/name&gt;&lt;script&gt;&lt;![CDATA[var debugTesting = Class.create();
debugTesting.prototype = {
    initialize: function() {
		this.debug = true;
    },
   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DefineReqCpe: function(NSProTask) {
        var LogPrefix = " DefineReqCpe --&gt; ";
        var serviceTable = "x_g_sonc_ns_pro_service_definition";
        var accumulateWorkNotes = "";
        var modelsRequired = [];
        var detailedRequiredCpeInventory = []; // 10/20/22 we are going to need to provide detail to the FS task.
        // it might be better to just make a related table of cpe requirements. would simplify everything.
        /*
        Driven by UI action.
        This function is meant to determine if there exists enough of a particular model in stock to fullfill 
        a provisioning function and then allocate models to the prov record.

        10/10/22 - Extended this function to handle LAN CPE, too.
        Provisioning rcd now allow for entry of the number of required LAN switch types. We will use that data to check for LAN switch
        CPE in stock.

        */
        var returnObject = {
            status: "",
            message: "",
            cpe: {
                model: "",
                available: false,
                inStockCount: 0
            }
        };
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "called for " + NSProTask.number);

        /* This first section needs to be done if this is for WAN provisioning with CPE
            if it is for something other than WAN, then we only need to concern ourselves with that part.
            See checks below. 
        */

        /* --------------------------------------------------------------------------------
            DO WAN RELATED CPE WORK
            10/18/22 Since we're combining wan and lan, only do this wan part if
            wan_cpe_ports_required is not blank or 0
        -----------------------------------------------------------------------------------
        */
        if (NSProTask.wan_cpe_ports_required != '' &amp;&amp; NSProTask.wan_cpe_ports_required != 0 &amp;&amp; NSProTask.wan_cpe_ports_required != null) {

            var defaultMedia = "mediaANYTHING";
            var mediaSearch = defaultMedia;
            var cpeQty = 1;

            // lets first find out what model(s) do we need based on the provisioning activity
            // We're going to have a process where the network analyst explicitly agrees and sets the assigned WAN service.
            var provInputValid = true;
            if (NSProTask.assigned_wan_service == null || NSProTask.assigned_wan_service == '') {
                provInputValid = false;
                returnObject.message = returnObject.message + " WAN service not explicitly set.";
            } else {
                // if we do have this wan service, then look it up and use this service code.
                var svcGR = new GlideRecord(serviceTable);
                assSvcRcdFound = svcGR.get(NSProTask.assigned_wan_service);
                if (assSvcRcdFound) {
                    var assSvcCode = svcGR.getValue('svc_code');
                    // we only care about media for broadband to determine LTE4G or not.
                    if (assSvcCode.charAt(0) == 'B') {
                        // then we need to know the media requested for the provisioning activity
                        if (NSProTask.wan_circuit_type_jack == null || NSProTask.wan_circuit_type_jack == '') {
                            provInputValid = false;
                            returnObject.message = returnObject.message + " WAN Circuit type jack undefined.";
                        } else {
                            mediaSearch = "media=" + NSProTask.wan_circuit_type_jack;
                        }
                    } else {
                        //
                        // TODO needed? will this order 4 when both circuits are processed? Commented out until verified
                        //
                        // if (assSvcCode.charAt(0) == 'G') {
                        //     // this is HA, so cpe qty = 2
                        //     cpeQty = 2;
                        // }
                    }
                }
            }
            if (NSProTask.wan_cpe_ports_required &lt; 1 || NSProTask.wan_cpe_ports_required == '') {
                provInputValid = false;
                returnObject.message = returnObject.message + " required ports unknown.";
            }

            // the search will be based on the following criteria
            // svc_code, media, number of ports required.
            // ex: mediaANYTHING^cpe_port_range_low&lt;=2^cpe_port_range_high&gt;=2^svc_code=SEW5M
            // First check that we have the needed criteria
            if (provInputValid) {
                // ok, we have all of the input we need to proceed
                // lets find the ordered, preferred cpe list for the service.
                var cpeModelReqSearch = mediaSearch + "^svc_code=" + assSvcCode +
                    "^cpe_port_range_low&lt;=" + NSProTask.wan_cpe_ports_required.toString() +
                    "^cpe_port_range_high&gt;=" + NSProTask.wan_cpe_ports_required.toString();

                var cpeModelOptions = this.getSvcCpeModelsBySearch(cpeModelReqSearch);

                if (this.debug) gs.info(this.timestamp() + LogPrefix + "determined model options are: " + JSON.stringify(cpeModelOptions));
                accumulateWorkNotes = "CPE Requirements Definition:\nModel options are " + cpeModelOptions.join() + "\n";

                if (cpeModelOptions.length &gt; 0) {
                    // now that we know what models we can use and in what preferred order,
                    // lets verify that we indeed have the quantity we need in stock.
                    var cpeEquipmentVerified = false;
                    // we need to make this loop through the options
                    for (var cpei = 0; cpei &lt; cpeModelOptions.length; cpei++) {
                        var verifyCpeResp = this.verifyCpe(cpeModelOptions[cpei], cpeQty, 'WAN');
                        if (this.debug) gs.info(this.timestamp() + LogPrefix + "verifyCpe response was " + JSON.stringify(verifyCpeResp));
                        if (verifyCpeResp.status == 'OK' &amp;&amp; verifyCpeResp.cpe.inStockCount &gt;= cpeQty) {
                            // set NSProTask
                            cpeEquipmentVerified = true;
                            // var modelsRequired = []; // move this to top, global
                            for (var i = 0; i &lt; cpeQty; i++) {
                                modelsRequired.push(verifyCpeResp.cpe.model);
                                detailedRequiredCpeInventory.push(verifyCpeResp); // 10/20/22 get details for cpe needs
                            }
                            // NSProTask.cpe_models_required = modelsRequired.join(); // move this below to handle lan models, too
                            // set a work note in the prov rcd
                            accumulateWorkNotes = accumulateWorkNotes + "Required WAN models:\n" + modelsRequired.join() + "\nVerified quantity in stock\n";
                            // NSProTask.provisoning_state = "6"; //CPE requirements defined  - moved to UI action
                            returnObject = verifyCpeResp;
                            break;
                        }
                    }
                    // if we reach here with no good model verification, alert the analyst.
                    if (!cpeEquipmentVerified) {
                        returnObject.status = "NOCPEINSTOCK";
                        returnObject.message = "No acceptable cpe models found available in stock. Unable to continue provisioning activity.";
                        gs.error(LogPrefix + returnObject.message + " for " + NSProTask.number);
                        accumulateWorkNotes = accumulateWorkNotes + "CPE: " + returnObject.message + "\n";
                        NSProTask.setValue('cpe_models_required', '');
                    }
                } else {
                    returnObject.status = "NOCPEOPTIONS";
                    returnObject.message = "No cpe models determined from service definition table search";
                    gs.error(this.timestamp() + LogPrefix + returnObject.message + " for " + NSProTask.number);
                    NSProTask.setValue('cpe_models_required', '');
                }
            } else {
                returnObject.status = "INPUTERROR";
                if (this.debug) gs.info(this.timestamp() + LogPrefix + "input error detected for " + NSProTask.number);
                NSProTask.setValue('cpe_models_required', '');
            }
        } else {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + "Skipping WAN CPE work since no ports required for " + NSProTask.number);
            returnObject.status = 'OK'
            returnObject.message = "No wan ports required."
        } // end do wan cpe work

        /* --------------------------------------------------------------------------------
            DO LAN RELATED CPE WORK
        -----------------------------------------------------------------------------------
        */
        // add call for lan cpe
        var cpeNeedsResp = this.verifyLANCpe(NSProTask);
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "cpeNeedsResp = " + JSON.stringify(cpeNeedsResp)) // lets see what we got 10/17/22
        // add more work_notes from lan cpe responses
        for (var crI = 0; crI &lt; cpeNeedsResp.cpe.length; crI++) {
            modelsRequired.push(cpeNeedsResp.cpe[crI].cpe.model);
            accumulateWorkNotes = accumulateWorkNotes + "LAN CPE: " + cpeNeedsResp.cpe[crI].message + "\n";
            detailedRequiredCpeInventory.push(cpeNeedsResp.cpe[crI]);
        }

        if (accumulateWorkNotes != "") {
            NSProTask.work_notes = accumulateWorkNotes;
        }

        // gather all req cpe and add to list.
        NSProTask.cpe_models_required = modelsRequired.join()
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "Detailed cpe needs for prov activity are: " + JSON.stringify(detailedRequiredCpeInventory));
        NSProTask.detailed_cpe_needs = JSON.stringify(detailedRequiredCpeInventory);

        NSProTask.update();
        return returnObject;
    },
    getSvcCpeModelsBySearch: function(searchStr) {
        var LogPrefix = " getSvcCpeModelsBySearch --&gt; ";
        var svcTable = "x_g_sonc_ns_pro_service_definition";
        /*
        This function returns a list of ordered cpe models for the service using 
        a given search string. 
        */
        var cpeModelList = [];
        if (this.debug) gs.info(this.timestamp() + LogPrefix + "called with " + searchStr);

        var scGR = new GlideRecord(svcTable);
        scGR.addEncodedQuery(searchStr);
        scGR.query();
        if (scGR.next()) {
            if (this.debug) gs.info(this.timestamp() + LogPrefix + "found svc record for cpe, " + scGR.getValue('sys_id') + ", " + scGR.getValue("svc_title"));
            for (var sindex = 1; sindex &lt; 5; sindex++) {
                var svcCpeVarName = "cpe_model_" + sindex.toString();
                var cpeMod = scGR.getValue(svcCpeVarName);
                if (cpeMod != "" &amp;&amp; cpeMod != null) {
                    cpeModelList.push(cpeMod);
                }
            }
        } else {
            gs.error(this.timestamp() + LogPrefix + "service definition record not found");
        }

        if (this.debug) gs.info(this.timestamp() + LogPrefix + 'returning cpeModelList of ' + cpeModelList);

        return cpeModelList;
    },
    type: 'debugTesting'
};]]&gt;&lt;/script&gt;&lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;&lt;sys_created_by&gt;admglfry&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2024-09-05 10:55:15&lt;/sys_created_on&gt;&lt;sys_id&gt;0fbc3a80872c9e10f9f20f280cbb3523&lt;/sys_id&gt;&lt;sys_mod_count&gt;3&lt;/sys_mod_count&gt;&lt;sys_name&gt;debugTesting&lt;/sys_name&gt;&lt;sys_package display_value="NS Pro" source="x_g_sonc_ns_pro"&gt;b5683ae81b157110824752c1604bcbc0&lt;/sys_package&gt;&lt;sys_policy&gt;read&lt;/sys_policy&gt;&lt;sys_scope display_value="NS Pro"&gt;b5683ae81b157110824752c1604bcbc0&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_script_include_0fbc3a80872c9e10f9f20f280cbb3523&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;admglfry&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2024-09-05 13:38:55&lt;/sys_updated_on&gt;&lt;/sys_script_include&gt;&lt;/record_update&gt;</payload>
        <payload_hash>464684148</payload_hash>
        <record_name>debugTesting</record_name>
        <reverted_from/>
        <source>66715de7475c5a1040fd43ff336d4352</source>
        <source_table>sys_update_set</source_table>
        <state>previous</state>
        <sys_created_by>admglfry</sys_created_by>
        <sys_created_on>2024-09-05 13:38:55</sys_created_on>
        <sys_id>7e42e30887e0de10f9f20f280cbb35fe</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_recorded_at>191c268d27d0000001</sys_recorded_at>
        <sys_updated_by>admglfry</sys_updated_by>
        <sys_updated_on>2024-09-05 13:38:55</sys_updated_on>
        <type>Script Include</type>
        <update_guid>7242e308fce0de10a17dfe73d61121fe</update_guid>
        <update_guid_history>7242e308fce0de10a17dfe73d61121fe:464684148,a58d3604152c9e10b88597438654e11c:-323081738,75fcb28819e89e10daa4a145eb040b97:-1146049576,d5dc36cc33e89e10315230366f318afd:-524307790</update_guid_history>
    </sys_update_version>
    <sys_metadata_delete action="INSERT_OR_UPDATE">
        <sys_audit_delete/>
        <sys_class_name>sys_metadata_delete</sys_class_name>
        <sys_created_by>admglfry</sys_created_by>
        <sys_created_on>2024-10-16 19:53:56</sys_created_on>
        <sys_db_object display_value="" name="sys_script_include">sys_script_include</sys_db_object>
        <sys_id>0d2c6df20a504f2d9a62afb847759cf1</sys_id>
        <sys_metadata>0fbc3a80872c9e10f9f20f280cbb3523</sys_metadata>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>debugTesting</sys_name>
        <sys_package display_value="NS Pro" source="x_g_sonc_ns_pro">b5683ae81b157110824752c1604bcbc0</sys_package>
        <sys_parent/>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="NS Pro">b5683ae81b157110824752c1604bcbc0</sys_scope>
        <sys_scope_delete display_value="">bd97b329774640a2bbe5a7af5f2552c9</sys_scope_delete>
        <sys_update_name>sys_script_include_0fbc3a80872c9e10f9f20f280cbb3523</sys_update_name>
        <sys_update_version display_value="sys_script_include_0fbc3a80872c9e10f9f20f280cbb3523">7e42e30887e0de10f9f20f280cbb35fe</sys_update_version>
        <sys_updated_by>admglfry</sys_updated_by>
        <sys_updated_on>2024-10-16 19:53:56</sys_updated_on>
    </sys_metadata_delete>
</record_update>
